package com.github.anno4j.schema_parsing.building;

import com.github.anno4j.Anno4j;
import com.github.anno4j.annotations.*;
import com.github.anno4j.schema_parsing.model.BuildableRDFSClazz;
import com.github.anno4j.schema_parsing.model.BuildableRDFSProperty;
import com.squareup.javapoet.*;
import org.junit.Before;
import org.junit.Test;
import org.openrdf.model.impl.URIImpl;
import org.openrdf.query.QueryEvaluationException;
import org.openrdf.repository.RepositoryException;
import org.openrdf.repository.object.ObjectConnection;

import java.io.File;
import java.io.FileInputStream;
import java.net.URL;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.*;

/**
 * Test for the generation of schema annotations to the property field in the generated support class.
 * Annotations are generated by {@link com.github.anno4j.schema_parsing.building.support.PropertySchemaAnnotationSupport}.
 */
public class SchemaAnnotationGenerationTest {

    /**
     * The Anno4j instance to which the ontology model is persisted by {@link #modelBuilder}.
     */
    private Anno4j anno4j;

    /**
     * A model builder generates a (extensive) ontology model from the input RDF.
     */
    private static OWLJavaFileGenerator modelBuilder;

    /**
     * Defines how Java names are generated.
     */
    private static OntGenerationConfig generationConfig;

    @Before
    public void setUp() throws Exception {
        anno4j = new Anno4j();

        generationConfig = new OntGenerationConfig();
        List<String> javaDocLangPreference = Arrays.asList("de", "en", OntGenerationConfig.UNTYPED_LITERAL);
        List<String> identifierLangPreference = Arrays.asList("en", "de", OntGenerationConfig.UNTYPED_LITERAL);
        generationConfig.setIdentifierLanguagePreference(identifierLangPreference);
        generationConfig.setJavaDocLanguagePreference(javaDocLangPreference);

        // Create a model builder instance:
        modelBuilder = new OWLJavaFileGenerator(anno4j);

        ClassLoader classLoader = getClass().getClassLoader();
        URL ontUrl = classLoader.getResource("restaurant_owl.ttl");
        File ontologyFile = new File(ontUrl.getFile());

        modelBuilder.addRDF(new FileInputStream(ontologyFile), "http://example.de/ont#", "TURTLE");

        // Build the model (persisted to anno4j):
        modelBuilder.build();
    }

    /**
     * Fetches the annotation specification of a certain type that the code generation would add to the field
     * in the generated support class.
     * @param declaringClazzIri The IRI of the class for which the field would be generated.
     * @param propertyIri The IRI of the property that is mapped by the field.
     * @param annotationType The type of the annotation to get.
     * @return Returns the JavaPoet annotation specification of the annotation if there is one of the given type.
     * Otherwise null is returned.
     * @throws RepositoryException Thrown if an error occurs while querying the connected repository.
     */
    private AnnotationSpec getBuiltAnnotation(String declaringClazzIri, String propertyIri, Class<?> annotationType) throws RepositoryException {
        ObjectConnection connection = modelBuilder.getConnection();
        BuildableRDFSClazz clazz;
        BuildableRDFSProperty property;
        try {
            clazz = connection.findObject(BuildableRDFSClazz.class, new URIImpl(declaringClazzIri));
            property = connection.findObject(BuildableRDFSProperty.class, new URIImpl(propertyIri));
        } catch (QueryEvaluationException e) {
            throw new RepositoryException(e);
        }

        MethodSpec field = property.buildGetter(clazz, generationConfig);
        for (AnnotationSpec currentAnnotation : field.annotations) {
            if(currentAnnotation.type.equals(AnnotationSpec.builder(annotationType).build().type)) {
                return currentAnnotation;
            }
        }
        return null;
    }

    @Test
    public void testFunctionalAnnotation() throws Exception {
        AnnotationSpec functionalAnnotation = getBuiltAnnotation("http://example.de/ont#Menu", "http://example.de/ont#has_main_dish", Functional.class);
        assertNotNull(functionalAnnotation);
    }

    @Test
    public void testInverseFunctionalAnnotation() throws Exception {
        AnnotationSpec inverseFunctionalAnnotation = getBuiltAnnotation("http://example.de/ont#Dish", "http://example.de/ont#isMainDishOf", InverseFunctional.class);
        assertNotNull(inverseFunctionalAnnotation);
    }

    @Test
    public void testSymmetricAnnotation() throws Exception {
        AnnotationSpec symmetricAnnotation = getBuiltAnnotation("http://example.de/ont#Dish", "http://example.de/ont#fits_with", Symmetric.class);
        assertNotNull(symmetricAnnotation);
    }

    @Test
    public void testTransitiveAnnotation() throws Exception {
        AnnotationSpec transitiveAnnotation = getBuiltAnnotation("http://example.de/ont#Dish", "http://example.de/ont#fits_with", Transitive.class);
        assertNotNull(transitiveAnnotation);
    }

    @Test
    public void testInverseOfAnnotation() throws Exception {
        AnnotationSpec servesInverseAnnotation = getBuiltAnnotation("http://example.de/ont#Restaurant", "http://example.de/ont#serves", InverseOf.class);
        assertNotNull(servesInverseAnnotation);
        assertEquals(1, servesInverseAnnotation.members.size());
        assertEquals(CodeBlock.of("{\"http://example.de/ont#served_at\"}"), servesInverseAnnotation.members.get("value").get(0));

        AnnotationSpec servedAtInverseAnnotation = getBuiltAnnotation("http://example.de/ont#Restaurant", "http://example.de/ont#served_at", InverseOf.class);
        assertNotNull(servedAtInverseAnnotation);
        assertEquals(1, servedAtInverseAnnotation.members.size());
        assertEquals(CodeBlock.of("{\"http://example.de/ont#serves\"}"), servedAtInverseAnnotation.members.get("value").get(0));
    }

    @Test
    public void testSubPropertyOfAnnotation() throws Exception {
        AnnotationSpec subPropertyAnnotation = getBuiltAnnotation("http://example.de/ont#Menu", "http://example.de/ont#has_main_dish", SubPropertyOf.class);
        assertNotNull(subPropertyAnnotation);
        assertEquals(CodeBlock.of("{\"http://example.de/ont#contains\"}"), subPropertyAnnotation.members.get("value").get(0));
    }

    @Test
    public void testBijectiveAnnotation() throws Exception {
        AnnotationSpec bijectiveAnnotation = getBuiltAnnotation("http://example.de/ont#Restaurant", "http://example.de/ont#name", Bijective.class);
        assertNotNull(bijectiveAnnotation);
    }

    @Test
    public void testMinCardinalityAnnotation() throws Exception {
        AnnotationSpec containerAnnotation = getBuiltAnnotation("http://example.de/ont#Menu", "http://example.de/ont#contains", MinCardinalities.class);
        assertNotNull(containerAnnotation);
        // There must be three entries separated by commas (qualified cardinality annotation do also contain each a comma, so plus 2):
        assertTrue(containerAnnotation.members.get("value").get(0).toString().matches("^\\{([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\}$"));

        AnnotationSpec unqualifiedAnnotation = AnnotationSpec.builder(MinCardinality.class)
                                                             .addMember("value", "2")
                                                             .build();
        ClassName mainDishType = anno4j.findByID(BuildableRDFSClazz.class, "http://example.de/ont#Main_Dish").getJavaPoetClassName(generationConfig);
        AnnotationSpec mainDishAnnotation = AnnotationSpec.builder(MinCardinality.class)
                                                            .addMember("value", "1")
                                                            .addMember("onClass",  CodeBlock.of("$T.class", mainDishType))
                                                            .build();
        ClassName drinkType = anno4j.findByID(BuildableRDFSClazz.class, "http://example.de/ont#Drink").getJavaPoetClassName(generationConfig);
        AnnotationSpec drinkAnnotation = AnnotationSpec.builder(MinCardinality.class)
                                                            .addMember("value", "1")
                                                            .addMember("onClass", CodeBlock.of("$T.class", drinkType))
                                                            .build();

        assertTrue(containerAnnotation.members.get("value").get(0).toString().contains(CodeBlock.of("$L", unqualifiedAnnotation).toString()));
        assertTrue(containerAnnotation.members.get("value").get(0).toString().contains(CodeBlock.of("$L", mainDishAnnotation).toString()));
        assertTrue(containerAnnotation.members.get("value").get(0).toString().contains(CodeBlock.of("$L", drinkAnnotation).toString()));
    }

    @Test
    public void testMaxCardinalityAnnotation() throws Exception {
        AnnotationSpec maxCardinalityAnnotation = getBuiltAnnotation("http://example.de/ont#Menu", "http://example.de/ont#contains", MaxCardinality.class);
        assertNotNull(maxCardinalityAnnotation);
        assertEquals(CodeBlock.of("5"), maxCardinalityAnnotation.members.get("value").get(0));
    }

    @Test
    public void testCardinalityAnnotation() throws Exception {
        AnnotationSpec cardinalityAnnotation = getBuiltAnnotation("http://example.de/ont#Restaurant", "http://example.de/ont#name", Cardinality.class);
        assertNotNull(cardinalityAnnotation);
        assertEquals(CodeBlock.of("1"), cardinalityAnnotation.members.get("value").get(0));
    }

    @Test
    public void testAllValuesFromAnnotation() throws Exception {
        AnnotationSpec annotation = getBuiltAnnotation("http://example.de/ont#ItalianMenu", "http://example.de/ont#contains", AllValuesFrom.class);
        assertNotNull(annotation);

        ClassName italianDishType = anno4j.findByID(BuildableRDFSClazz.class, "http://example.de/ont#ItalianDish").getJavaPoetClassName(generationConfig);
        assertEquals(CodeBlock.of("{$T.class}", italianDishType), annotation.members.get("value").get(0));
    }

    @Test
    public void testSomeValuesFromAnnotation() throws Exception {
        AnnotationSpec annotation = getBuiltAnnotation("http://example.de/ont#PartialItalianMenu", "http://example.de/ont#contains", SomeValuesFrom.class);
        assertNotNull(annotation);

        ClassName italianDishType = anno4j.findByID(BuildableRDFSClazz.class, "http://example.de/ont#ItalianDish").getJavaPoetClassName(generationConfig);
        assertEquals(CodeBlock.of("{$T.class}", italianDishType), annotation.members.get("value").get(0));
    }
}
